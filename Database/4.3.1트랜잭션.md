# 트랜잭션 (Transaction)

트랜잭션은 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위를 말하며, 데이터베이스에 접근하는 방법은 쿼리이므로, 여러 개의 쿼리들을 하나로 묶는 단위를 말합니다. 트랜잭션의 주요 목적은 여러 작업이 포함된 프로세스에서 **데이터 무결성**을 보장하고, 시스템 장애나 에러 발생 시 일관된 상태로 복원할 수 있게 하는 것입니다.

## 트랜잭션의 주요 특징 (ACID 속성)

트랜잭션은 **ACID** 속성이라고 불리는 네 가지 특징을 가지고 있습니다.

### 1. Atomicity (원자성)

트랜잭션 내의 모든 작업은 하나의 단위로 간주됩니다. 따라서 트랜잭션 내의 작업이 **모두 성공하든지, 모두 실패하든지** 해야 합니다. 일부만 성공하거나 실패할 수 없으며, 작업 중 하나라도 실패하면 전체 트랜잭션이 취소되고 이전 상태로 되돌아갑니다.

#### 예시

홍철이가 1000만원을 가진 상태에서 규영이에게 500만원을 이체한다고 가정해보겠습니다. 이때 결과는 다음과 같은 작업 단위들로 이루어집니다.

1. 홍철의 잔고를 조회합니다.
2. 홍철의 잔고에서 500만원을 뺍니다.
3. 규영의 잔고에 500만원을 추가합니다.

트랜잭션이 취소되면 홍철의 잔고는 다시 1000만원, 규영의 잔고는 0원이 됩니다. 이처럼 트랜잭션은 **모두 성공하거나 모두 실패**해야 합니다.

트랜잭션의 주요 과정
- **트랜잭션**: 트랜잭션이 시작되면 데이터 베이스는 사용자의 요청에 따라 데이터 수정, 삭제, 삽입 등의 작업을 수행한다.
- **작업 수행**: 트랜잭션 내에서 여러 작업이 수행됩니다. 이 작업들은 하나의 논리적 단위로 간주되며, 트랜잭션 전체가 성공적으로 끝나거나 실패할 수 있다.
- **커밋(Commit)**: 트랜잭션 내 작업이 모두 성공하면, 트랜잭션을 커밋하여 데이터베이스에 모든 변경 사항을 반영합니다. 이때부터 변경된 데이터는 영구적이다.
- **롤백(RollBack)**: 트랜잭션 중 하나라도 실패하면, 트랜잭션을 롤백하여 모든 작업을 취소하고 데이터베이스를 트랜잭션 이전 상태로 되돌린다.

![img (1)](https://github.com/user-attachments/assets/ce1ba2c5-3955-4719-ae87-ca39be94401b)


### 2. Consistency (일관성)

트랜잭션이 시작되기 전과 끝난 후에 데이터가 **유효한 상태**를 유지하는 것을 의미합니다. 트랜잭션이 데이터베이스 규칙이나 제약 조건을 위반하지 않고 정상적으로 처리되도록 보장합니다.

#### 예시

계좌 A에는 500,000만원이 있고, 계좌 B에는 300,000원이 있습니다. A에서 B로 100,000원을 이체할 때 트랜잭션 도중 문제가 발생하면, A의 금액은 원래 상태로 복구되어 **일관성**이 유지됩니다.

### 3. Isolation (격리성)

격리성은 여러 트랜잭션이 동시에 실행될 때 **서로 영향을 받지 않도록** 보장합니다. 즉, 트랜잭션이 진행되는 동안에는 다른 트랜잭션이 그 데이터를 읽거나 수정할 수 없습니다.

#### 동시성 문제

- **Dirty Read**: 트랜잭션이 아직 완료되지 않은 데이터를 다른 트랜잭션에서 읽는 상황.
- **Non-repeatable Read**: 한 트랜잭션에서 읽은 데이터를 같은 트랜잭션 내에서 다시 읽을 때 값이 달라지는 상황.
- **Phantom Read**: 한 트랜잭션이 데이터를 읽을 때, 다른 트랜잭션이 새로운 데이터를 추가하여 다시 조회할 때 결과 집합이 달라지는 상황.

### 4. Durability (지속성)

트랜잭션이 성공적으로 완료되면, 그 결과는 **영구적으로 데이터베이스에 저장**됩니다. 이후 시스템 장애가 발생해도 트랜잭션의 결과는 손실되지 않습니다.

![img](https://github.com/user-attachments/assets/847e7ba6-3dc6-410e-b76b-424c0a4b93b7)

---

## 트랜잭션의 주요 과정

1. **트랜잭션 시작**: 트랜잭션이 시작되면 데이터베이스는 사용자의 요청에 따라 데이터 수정, 삭제, 삽입 등의 작업을 수행합니다.
2. **작업 수행**: 트랜잭션 내에서 여러 작업이 수행됩니다. 이 작업들은 하나의 논리적 단위로 간주됩니다.
3. **커밋(Commit)**: 트랜잭션 내 작업이 모두 성공하면, 커밋하여 데이터베이스에 모든 변경 사항을 반영합니다. 이때부터 변경된 데이터는 영구적입니다.
4. **롤백(Rollback)**: 트랜잭션 중 하나라도 실패하면, 트랜잭션을 롤백하여 모든 작업을 취소하고 데이터베이스를 트랜잭션 이전 상태로 되돌립니다.

---

## 격리 수준 (Isolation Level)

데이터베이스는 **성능과 동시성 제어**의 균형을 맞추기 위해 다양한 격리 수준을 제공합니다. 격리 수준은 트랜잭션 간의 간섭을 얼마나 허용할지 결정하며, 각 수준은 동시성 문제를 해결하는 정도에 따라 구분됩니다.

### 1. Read Uncommitted (읽기 미완료)

- 트랜잭션이 커밋되지 않은 데이터를 다른 트랜잭션에서 읽을 수 있습니다.
- **Dirty Read** 발생 가능성이 있습니다.

### 2. Read Committed (읽기 완료)

- 트랜잭션이 완료된(커밋된) 데이터만 읽을 수 있습니다.
- **Dirty Read**는 방지되지만, **Non-repeatable Read**는 발생할 수 있습니다.

### 3. Repeatable Read (반복 가능 읽기)

- 트랜잭션이 시작된 후, 동일한 데이터를 여러 번 읽어도 값이 변하지 않도록 보장합니다.
- **Non-repeatable Read**는 방지되지만, **Phantom Read**는 여전히 발생할 수 있습니다.

### 4. Serializable (직렬화 가능)

- 가장 높은 수준의 격리성으로, 모든 트랜잭션을 순차적으로 실행하는 것처럼 보이게 만듭니다.
- **Dirty Read**, **Non-repeatable Read**, **Phantom Read**를 모두 방지합니다.



## 격리 수준 요약

| 격리 수준          | Dirty Read 방지 | Non-repeatable Read 방지 | Phantom Read 방지 |
|-------------------|-----------------|--------------------------|-------------------|
| Read Uncommitted  | X               | X                        | X                 |
| Read Committed    | O               | X                        | X                 |
| Repeatable Read   | O               | O                        | X                 |
| Serializable      | O               | O                        | O                 |

---

## 트랜잭션의 중요성

트랜잭션을 통해 **데이터 무결성과 일관성**을 보장할 수 있습니다. 트랜잭션이 없다면 데이터베이스는 여러 사용자에 의해 동시에 접근될 때 항상 올바르고 일관된 상태를 유지할 수 없게 됩니다.
