미완성된 답변이 전달된 것 같네요. 다시 정리해서 답변 드릴게요.

### 자료 구조(Data Structure)란?
자료 구조는 데이터를 효율적으로 저장하고, 수정, 삭제, 탐색할 수 있는 방법을 제공하는 데이터 집합입니다. 알고리즘의 성능을 높이기 위해 적절한 자료 구조를 선택하는 것이 중요합니다.

### 시간 복잡도(Time Complexity)
시간 복잡도는 알고리즘이 입력 크기 \(n\)에 따라 얼마나 시간이 걸리는지를 나타내는 척도입니다. 이를 **빅오 표기법(Big-O Notation)** 으로 표현하여, 최악의 경우에 얼마나 많은 작업을 수행해야 하는지 설명합니다.

#### 자주 사용되는 시간 복잡도
1. **O(1)**: 입력 크기에 상관없이 항상 일정한 시간이 걸립니다. (예: 배열의 첫 번째 요소 조회)
2. **O(log n)**: 입력 크기가 커질수록 시간이 느리게 증가합니다. 보통 **이진 탐색(Binary Search)** 에서 발생합니다.
3. **O(n)**: 입력 크기에 비례하여 시간이 증가합니다. (예: 배열에서 최대값 찾기)
4. **O(n log n)**: 효율적인 **정렬 알고리즘(퀵 정렬, 병합 정렬)** 에서 자주 등장합니다.
5. **O(n²)**: 중첩 반복문이 있을 때 발생합니다. (예: 버블 정렬)
6. **O(2^n)**: 재귀적으로 모든 경우의 수를 탐색할 때 발생합니다. (예: 피보나치 수열)

![시간 복잡도 비교 drawio](https://github.com/user-attachments/assets/6414743b-d279-484c-aa00-92ee71434674)

### 시간 복잡도 예시
- **배열에서 최대값 찾기**: 시간 복잡도는 O(n)입니다. 모든 요소를 확인해야 하기 때문입니다.
- **이진 탐색(Binary Search)**: 시간 복잡도는 O(log n)입니다. 중간 값을 기준으로 범위를 절반씩 줄이기 때문에 효율적입니다.

### 정렬 알고리즘 비교
- **퀵 정렬(Quick Sort)**: 평균적으로 O(n log n)의 시간 복잡도를 가지며, 피벗을 기준으로 두 그룹으로 나눈 후 정렬합니다.
- **병합 정렬(Merge Sort)**: 모든 경우에 O(n log n)의 시간 복잡도를 가지며, 배열을 반으로 나누고, 정렬 후 병합합니다.
- **버블 정렬(Bubble Sort)**: 간단하지만 비효율적인 정렬 알고리즘으로, 최악의 경우 O(n²)입니다.

