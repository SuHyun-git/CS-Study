# 벡터(Vector)

벡터는 동적 배열을 기반으로 하는 자료 구조로, 배열과 유사하게 데이터를 순차적으로 저장하지만 몇 가지 중요한 차이점과 추가적인 기능을 제공합니다. 벡터는 주로 프로그래밍 언어의 표준 라이브러리에서 제공되며, Java의 `ArrayList`, C++의 `std::vector` 등이 그 예입니다.

## 정의 및 동작 원리

벡터는 데이터 요소를 연속적으로 저장하는 자료 구조로, 크기가 동적으로 조정됩니다. 벡터의 동작 원리는 다음과 같습니다:

1. **초기화**
    - 벡터는 일반적으로 초기 용량을 지정할 수 있으며, 이 용량만큼의 메모리를 할당받습니다. 이 초기 용량은 벡터에 저장할 수 있는 요소의 수를 나타냅니다.

2. **추가**
    - 요소를 추가할 때, 현재 용량이 가득 찼다면 벡터는 새로운 배열을 생성하고 기존 데이터를 복사합니다. 일반적으로 새 배열의 크기는 기존 배열의 두 배로 설정됩니다. 이 과정에서 성능이 저하될 수 있지만, 추가적인 공간이 확보되므로 이후의 추가 연산은 더 효율적으로 수행될 수 있습니다.

3. **삭제**
    - 요소를 삭제할 때는 삭제된 요소의 뒤에 있는 모든 요소를 한 칸씩 앞으로 이동시켜야 하므로 `O(n)`의 시간 복잡도가 발생합니다. 이 과정은 요소가 삭제되는 위치에 따라 성능에 영향을 미칠 수 있습니다.

4. **접근**
    - 벡터는 인덱스를 사용하여 데이터를 저장하므로 랜덤 접근이 가능하며, 특정 인덱스의 요소에 `O(1)`의 시간 복잡도로 접근할 수 있습니다.

## 주요 특징

1. **동적 크기**
    - 사용자가 필요에 따라 요소를 추가하거나 삭제할 수 있으므로 벡터의 크기가 유동적입니다. 이로 인해 고정된 크기의 배열보다 유연하게 데이터를 처리할 수 있습니다.

2. **연속적인 메모리**
    - 벡터는 내부적으로 연속된 메모리 블록에 저장되므로, 데이터에 빠르게 접근할 수 있습니다. 이는 메모리 캐시의 효율성을 높이는 데 기여합니다.

3. **풍부한 메서드**
    - 벡터는 다양한 메서드를 제공하여 요소를 추가, 삭제, 검색하는 작업을 간편하게 수행할 수 있도록 합니다. 예를 들어, Java의 `ArrayList`에서는 `add()`, `remove()`, `get()`, `size()` 등의 메서드를 제공합니다.

## 자바로 보는 예시 코드

```java
import java.util.ArrayList;

public class VectorExample {
    public static void main(String[] args) {
        // 벡터 생성
        ArrayList<Integer> vector = new ArrayList<>();

        // 요소 추가
        vector.add(10);   // 인덱스 0
        vector.add(20);   // 인덱스 1
        vector.add(30);   // 인덱스 2
        System.out.println("벡터의 요소: " + vector);  // 출력: [10, 20, 30]

        // 요소 삭제
        vector.remove(1); // 인덱스 1의 요소(20) 삭제
        System.out.println("삭제 후 요소: " + vector);  // 출력: [10, 30]

        // 특정 인덱스의 요소에 접근
        int value = vector.get(0);
        System.out.println("첫 번째 요소: " + value);  // 출력: 10

        // 벡터의 크기 확인
        System.out.println("벡터의 크기: " + vector.size());  // 출력: 2

        // 모든 요소 출력
        for (Integer num : vector) {
            System.out.println("요소: " + num);
        }
    }
}
```

## 장점

- **동적 크기 조정**  
  필요에 따라 배열의 크기를 자동으로 조정하므로, 데이터의 양이 불확실할 때 유용합니다.

- **랜덤 접근 가능**  
  배열처럼 인덱스를 사용하여 요소에 빠르게 접근할 수 있어 성능이 뛰어납니다.

- **유연한 데이터 처리**  
  다양한 메서드를 제공하여 데이터 삽입, 삭제, 검색 등을 간편하게 처리할 수 있습니다.

## 단점

- **메모리 오버헤드**  
  벡터는 내부적으로 동적 메모리를 할당하고 관리해야 하므로 메모리 오버헤드가 발생할 수 있습니다. 또한, 크기를 조정할 때마다 새로운 메모리 블록을 할당하고 데이터를 복사해야 하므로, 추가 작업에서 성능 저하가 발생할 수 있습니다.

- **비효율적인 삽입/삭제**  
  중간에 요소를 삽입하거나 삭제할 경우, 모든 후속 요소를 이동해야 하므로 `O(n)`의 시간 복잡도가 소요되어 비효율적일 수 있습니다.

---

**메모리 오버헤드(Memory Overhead)**: 프로그램이 실행될 때, 실제로 필요한 메모리 양 외에 추가로 사용되는 메모리 공간을 의미합니다.