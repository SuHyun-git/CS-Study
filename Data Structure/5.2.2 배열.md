## 배열 (Array)

(여기서는 정적 배열을 기반으로 설명합니다.)  
고정된 크기의 연속된 메모리 공간에 저장된 데이터 집합으로, 배열의 크기는 선언 시에 결정되고 이후에는 변경할 수 없습니다. 배열의 각 요소는 인덱스(index)를 통해 접근할 수 있으며, 이러한 접근 방식은 크게 두 가지로 구분됩니다: **랜덤 접근(random access)**과 **순차 접근(sequential access)**입니다.

### 1. 랜덤 접근 (Random Access)

랜덤 접근은 배열의 임의의 인덱스에 직접 접근하는 방식입니다. 이 접근 방식은 배열의 특징인 인덱스를 통한 빠른 접근 속도 때문에 가능하며, 정적 배열의 경우 O(1)의 시간 복잡도를 가집니다.

#### 랜덤 접근의 특징
- **빠른 접근 속도**: 인덱스를 사용하여 배열의 특정 위치에 있는 요소에 즉시 접근할 수 있습니다. 예를 들어, 배열 `arr`의 다섯 번째 요소에 접근하려면 `arr[4]`라고 작성하면 되며, 배열의 크기와 관계없이 즉시 해당 요소에 접근할 수 있습니다.
- **연속적인 메모리 할당**: 배열의 요소들은 메모리에서 연속적으로 할당되므로, 특정 인덱스에 대한 주소를 직접 계산하여 접근할 수 있습니다. 배열의 첫 번째 요소의 메모리 주소를 `base_address`라고 하면, n번째 요소의 주소는 `base_address + (n * element_size)`로 쉽게 계산할 수 있습니다.
- **효율적**: 랜덤 접근은 데이터 검색이 빠르고 효율적이며, 특정 요소를 수정하거나 확인할 때 유리합니다.

#### 예제 코드
```java
public class RandomAccessExample {
    public static void main(String[] args) {
        int[] arr = {10, 20, 30, 40, 50};

        // 특정 인덱스의 요소에 접근 (랜덤 접근)
        int value = arr[2];  // arr의 세 번째 요소에 접근 (index 2)
        System.out.println("세 번째 요소: " + value);  // 출력: 세 번째 요소: 30

        // 특정 인덱스의 요소를 수정
        arr[4] = 100;  // arr의 다섯 번째 요소를 100으로 변경
        System.out.println("변경된 다섯 번째 요소: " + arr[4]);  // 출력: 변경된 다섯 번째 요소: 100
    }
}
```

### 2. 순차 접근 (Sequential Access)

순차 접근은 배열의 요소에 처음부터 차례대로 접근하는 방식입니다. 특정 위치에서 바로 접근하는 랜덤 접근과 달리, 순차 접근은 배열의 첫 번째 요소부터 차례대로 이동하면서 접근합니다.

#### 순차 접근의 특징
- **첫 번째 요소부터 차례대로 접근**: 배열의 처음부터 순차적으로 다음 요소로 이동하면서 접근합니다. 예를 들어, 배열의 모든 요소를 출력하거나 특정 조건에 맞는 요소를 찾는 경우에 사용됩니다.
- **배열 전체 순회에 용이**: 순차 접근은 배열의 모든 요소를 확인해야 할 때 적합합니다. 예를 들어, 배열 내의 최대값을 찾거나 모든 요소를 더하는 경우 순차 접근이 필요합니다.
- **O(n) 시간 복잡도**: 배열의 길이가 n일 때, 순차 접근을 통해 배열의 모든 요소를 확인하는 데는 O(n) 시간이 걸립니다.

#### 예제 코드
```java
public class SequentialAccessExample {
    public static void main(String[] args) {
        int[] arr = {5, 10, 15, 20, 25};
        int sum = 0;

        // 순차 접근을 통해 배열의 모든 요소를 더함
        for (int i = 0; i < arr.length; i++) {
            sum += arr[i];  // 각 요소를 더함
        }

        System.out.println("배열 요소의 합: " + sum);  // 출력: 배열 요소의 합: 75
    }
}
```

## 배열과 연결 리스트 비교

배열은 상자를 순서대로 나열한 데이터 구조이며 몇 번째 상자인지만 알면 해당 상자의 요소를 끄집어낼 수 있습니다.  
연결 리스트는 상자를 선으로 연결한 형태의 데이터 구조이며, 상자 안의 요소를 알기 위해서는 하나씩 상자 내부를 확인해봐야 한다는 점이 다릅니다.

### 배열 (Array)
- **접근 방법**: 인덱스를 사용하여 랜덤 접근이 가능하며, O(1)의 시간 복잡도로 요소에 접근할 수 있음.
- **메모리**: 연속된 메모리 공간에 저장되며, 배열의 크기는 선언 시에 고정됨.

#### 장점
- 빠른 데이터 접근 (랜덤 접근).
- 메모리 효율성이 높음 (메모리 할당과 해제가 필요 없음).

#### 단점
- 크기가 고정되어 있어, 크기를 변경하려면 새 배열을 생성하고 복사해야 함.
- 중간에 요소를 삽입하거나 삭제할 때 비효율적 (O(n)).

### 연결 리스트 (Linked List)
- **접근 방법**: 순차적으로 접근해야 하며, 특정 요소에 접근하는 데 O(n)의 시간 복잡도 소요.
- **메모리**: 노드들이 메모리의 불연속적인 위치에 저장되며, 각 노드가 다음 노드를 가리키는 포인터를 가짐.

#### 장점
- 크기를 동적으로 조절 가능 (노드를 추가하거나 삭제하는 데 유연함).
- 중간에 요소를 삽입하거나 삭제할 때 효율적 (O(1), 단 노드를 찾는 데는 O(n)).

#### 단점
- 메모리 사용량이 더 많음 (포인터를 저장해야 하므로).
- 랜덤 접근이 불가능하여 데이터 접근 속도가 느림.
