### 선점형 스케줄링(Preemptive Scheduling)

현재 실행 중인 프로세스를 중단하고, 더 높은 우선순위를 가진 프로세스나 새로 도착한 프로세스에 CPU를 할당하는 스케줄링 방식입니다. 즉, 이미 CPU를 할당받은 프로세스가 완료되지 않았더라도, 더 중요한 작업이 있으면 CPU 제어권을 빼앗깁니다.

이 방식은 비선점형 스케줄링과 달리, 프로세스가 CPU를 독점하지 못하고 중간에 다른 프로세스에 의해 선점될 수 있어 동적이고 실시간적인 자원 배분에 유리합니다.

#### 선점형 스케줄링의 동작 방식

1. **새로운 프로세스 도착**: 새로운 프로세스가 도착하면, 스케줄러는 현재 실행 중인 프로세스와 도착한 프로세스의 우선순위나 CPU 할당 기준을 비교합니다.
2. **현재 프로세스 중단 가능**: 새로운 프로세스가 더 높은 우선순위를 가지거나, 더 중요한 프로세스일 경우, 현재 실행 중인 프로세스를 중단하고 새로운 프로세스에 CPU를 할당합니다.
3. **중단된 프로세스 재개**: 중단된 프로세스는 나중에 다시 재개되어 작업을 마칩니다. 이 과정에서 문맥 전환(Context Switch)이 발생하게 됩니다.

---

### 라운드 로빈 스케줄링(Round Robin Scheduling)

각 프로세스에 고정된 시간(Time Quantum) 동안만 CPU를 할당하고, 그 시간이 지나면 다음 프로세스에 CPU를 할당하는 방식입니다. 모든 프로세스가 순서대로 돌아가며 공평하게 CPU를 사용하게 됩니다.

라운드 로빈 스케줄링은 선점형 스케줄링 방식의 대표적인 예로, 멀티태스킹 운영체제에서 많이 사용됩니다. FCFS(First-Come, First-Served) 스케줄링의 공평성을 유지하면서도, 각 프로세스가 일정 시간 이상 CPU를 독점하지 않도록 보장합니다.

#### 라운드 로빈 스케줄링의 동작 방식

1. **프로세스 대기열**: 모든 프로세스는 큐(Queue)에 저장되며, 순서대로 CPU를 할당받습니다.
2. **타임 퀀텀(Time Quantum)**: 각 프로세스는 일정한 시간(타임 퀀텀) 동안만 CPU를 사용할 수 있습니다.
3. **시간 초과**: 프로세스가 타임 퀀텀 내에 완료되지 않으면 중단되고, 큐의 마지막으로 이동하여 다시 대기합니다.
4. **다시 할당**: 그 다음 프로세스가 CPU를 할당받고, 순차적으로 반복됩니다.

#### 라운드 로빈 스케줄링의 예시

| 프로세스 | 실행 시간 (Burst Time) | 도착 시간 |
|----------|------------------------|------------|
| P1       | 5                      | 0          |
| P2       | 8                      | 1          |
| P3       | 6                      | 2          |
| P4       | 4                      | 3          |
![img](https://github.com/user-attachments/assets/29d9246e-7c06-41c1-8c06-b1b037cfd826)



스케줄링 순서:  
**P1 → P2 → P3 → P4 → P1 → P2 → P3**

#### 라운드 로빈 스케줄링의 특징

- **타임 퀀텀(Time Quantum)**:  
  타임 퀀텀이 짧을수록 응답 시간이 짧아지지만 문맥 전환이 빈번하게 발생하여 오버헤드가 증가할 수 있습니다. 타임 퀀텀이 길면 문맥 전환이 줄어들지만 응답 시간이 길어져 특정 프로세스가 CPU를 독점할 수 있습니다.

- **선점형 스케줄링**:  
  라운드 로빈은 선점형 스케줄링의 일종으로, 타임 퀀텀이 지나면 프로세스가 중단되고 다른 프로세스가 CPU를 사용할 수 있습니다.

- **평등한 자원 분배**:  
  모든 프로세스가 같은 시간만큼 CPU를 할당받으므로, 공평한 CPU 자원 분배가 가능합니다.

- **문맥 전환(Context Switch)**:  
  타임 퀀텀이 끝나면 CPU 제어권을 다른 프로세스로 넘기기 위해 문맥 전환이 발생합니다. 문맥 전환에는 시간이 소요되며, 빈번한 문맥 전환은 오버헤드를 증가시킬 수 있습니다.

#### 라운드 로빈 스케줄링의 장점

- **응답 시간 보장**: 각 프로세스가 일정 시간 내에 CPU를 할당받아 실행되므로, 예측 가능한 응답 시간이 보장됩니다.
- **공평성**: 모든 프로세스가 동일한 시간만큼 CPU를 할당받기 때문에 자원의 공평한 분배가 가능합니다.
- **Starvation(기아 현상) 없음**: 우선순위 기반 스케줄링에서 발생할 수 있는 기아 현상이 발생하지 않습니다.

#### 라운드 로빈 스케줄링의 단점

- **오버헤드 증가**: 짧은 타임 퀀텀일수록 문맥 전환이 자주 발생하여 시스템 오버헤드가 증가할 수 있습니다.
- **CPU 버스트가 짧은 프로세스에 불리**: CPU 버스트가 짧은 프로세스는 더 긴 프로세스와 같은 대기 시간을 가지며 비효율적으로 처리될 수 있습니다.
- **타임 퀀텀 설정의 어려움**: 타임 퀀텀을 적절하게 설정하지 않으면 오버헤드가 높아지거나 응답 속도가 느려질 수 있습니다.

#### 라운드 로빈 스케줄링의 활용

- 멀티태스킹 운영체제에서 여러 프로세스가 동시에 실행되는 것처럼 보이도록 만드는 데 적합합니다.
- 타임 쉐어링 시스템에서 공정하게 CPU 자원을 분배해야 하는 상황에 자주 사용됩니다.
- 인터랙티브 시스템에서 빠른 응답 시간이 요구되는 환경에 적합합니다.

---

### SRF(Shortest Remaining Time First, SRTF)

남은 실행 시간이 가장 짧은 프로세스에게 CPU를 우선적으로 할당하는 방식입니다. SRTF는 비선점형 SJF(Shortest Job First) 알고리즘의 선점형 버전입니다. 프로세스가 실행 중이더라도 남은 실행 시간이 더 짧은 다른 프로세스가 도착하면 CPU를 즉시 해당 프로세스에게 넘깁니다.

#### SRF(SRTF)의 동작 방식

1. **프로세스 도착**: CPU 스케줄러는 대기 중인 모든 프로세스와 현재 실행 중인 프로세스의 남은 실행 시간을 비교합니다.
2. **선점**: 새로운 프로세스가 도착했을 때, 그 프로세스의 남은 실행 시간이 더 짧으면 현재 실행 중인 프로세스를 중단하고 새로운 프로세스에게 CPU를 할당합니다.
3. **프로세스 완료**: 해당 프로세스가 완료될 때까지 실행되며, 완료 후 다시 대기 큐에서 가장 남은 시간이 짧은 프로세스를 선택하여 실행합니다.

#### SRF의 예시

| 프로세스 | 도착 시간 | 실행 시간 |
|----------|-----------|------------|
| P1       | 0         | 8          |
| P2       | 1         | 4          |
| P3       | 2         | 9          |
| P4       | 3         | 5          |

**SRF 스케줄링 순서**
- 0초: P1 실행
- 1초: P2 도착 → P2 실행
- 2초: P2 계속 실행 (P2 남은 시간이 더 짧음)
- 3초: P2 계속 실행 (P4 남은 시간이 더 길음)
- 5초: P2 종료 → P4 실행
- 10초: P4 종료 → P1 실행
- 17초: P1 종료 → P3 실행

![img (1)](https://github.com/user-attachments/assets/1b2ec6bf-9429-4380-afd7-d6d5ef5909d3)


#### SRF의 장점!

- **대기 시간 최소화**: 남은 시간이 짧은 프로세스를 우선 처리하여 대기 시간과 응답 시간을 최소화할 수 있습니다.
- **공정성**: 작업 시간이 짧은 프로세스는 빠르게 처리되고, 오래 걸리는 프로세스는 뒤로 밀릴 수 있지만 선점형 방식 덕분에 공정하게 CPU를 분배받습니다.

#### SRF의 단점

- **Starvation(기아 현상)**: 긴 실행 시간을 가진 프로세스는 계속해서 더 짧은 프로세스에게 CPU를 빼앗길 수 있으며, 기아 현상이 발생할 수 있습니다.
- **문맥 전환 오버헤드**: 선점형 방식이기 때문에 자주 문맥 전환이 일어나며, 이로 인해 시스템 자원의 낭비와 성능 저하가 발생할 수 있습니다.

#### SRF와 SJF 비교

- **SJF(Shortest Job First)**: 남은 시간을 고려하지 않고, 처음부터 실행 시간이 짧은 프로세스를 선택하여 비선점형 방식으로 실행합니다.
- **SRF(Shortest Remaining First)**: 프로세스 실행 중에도 남은 실행 시간이 더 짧은 프로세스가 도착하면 선점하여 더 짧은 프로세스를 우선적으로 실행합니다.

### 다단계 큐(Multilevel Queue)

다단계 큐 스케줄링은 시스템 내의 프로세스를 여러 개의 큐로 나누어 처리하는 방식입니다. 각 큐는 우선순위가 다르며, 각 큐에서 실행되는 프로세스는 서로 다른 스케줄링 알고리즘을 사용할 수 있습니다. 예를 들어, 하나의 큐는 라운드 로빈(Round Robin) 알고리즘을, 다른 큐는 우선순위 기반 스케줄링을 사용할 수 있습니다.

---

### 주요 개념

1. **큐의 분류**:
  - 프로세스는 **우선순위**, **프로세스 종류(시스템 프로세스, 사용자 프로세스 등)**, 또는 다른 기준에 따라 서로 다른 큐로 분류됩니다.
  - 시스템 프로세스는 **높은 우선순위** 큐에 배치되고, 사용자 프로세스는 **낮은 우선순위** 큐에 배치될 수 있습니다.

2. **큐 간 스케줄링**:
  - 각 큐는 독립적으로 스케줄링됩니다.
  - 높은 우선순위 큐의 프로세스가 먼저 실행되며, 그 큐가 비어 있을 때에만 낮은 우선순위 큐의 프로세스가 실행됩니다.

3. **큐 내부 스케줄링**:
  - 각 큐는 별도의 스케줄링 알고리즘을 사용할 수 있습니다.
  - 높은 우선순위 큐에서는 **짧은 응답 시간**을 보장하기 위해 라운드 로빈 같은 **선점형 스케줄링**이 사용될 수 있고, 낮은 우선순위 큐에서는 **CPU 시간을 더 효율적으로** 사용하기 위해 **비선점형 스케줄링**(FCFS 등)이 사용될 수 있습니다.

---

### 장점

- **효율성**: 다단계 큐는 시스템 프로세스와 사용자 프로세스를 명확히 구분하여 **중요한 프로세스가 더 빠르게 처리**될 수 있습니다.
- **유연성**: 큐마다 **다른 스케줄링 정책**을 적용할 수 있어 다양한 작업에 대응할 수 있습니다.

---

### 단점

- **비탄력성**: 한 번 특정 큐에 속한 프로세스는 **다른 큐로 이동할 수 없습니다**.
- **기아 현상**: **낮은 우선순위** 큐에 있는 프로세스는 **높은 우선순위 큐**가 바쁘면 **실행되지 못할 가능성**이 있습니다.

---

### 결론

다단계 큐는 다양한 우선순위의 작업을 효율적으로 처리하기 위한 좋은 방법이지만, 기아 현상을 방지하기 위한 보완이 필요할 수 있습니다.
