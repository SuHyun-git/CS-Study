# CPU 스케줄링 알고리즘

CPU 스케줄링 알고리즘은 CPU의 작업 처리 순서를 결정하는 방법으로, 여러 프로세스가 CPU를 공유해야 할 때 효율적으로 CPU 자원을 배분하는 데 사용됩니다. 각 알고리즘은 서로 다른 방식으로 CPU를 할당하며, 처리 시간, 우선순위, 대기 시간 등을 고려합니다.

[CPU 스케줄링 알고리즘.drawio.png](..%2F..%2F..%2FDownloads%2FCPU%20%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.drawio.png)

프로그램이 실행될 때 CPU 스케줄링 알고리즘은 어떤 프로그램에 CPU 소유권을 줄 것인지 결정하며, 이 과정에서 CPU 이용률을 높이고 주어진 시간에 많은 일을 처리하며, 준비 큐에 있는 프로세스는 적게 유지하고, 응답 시간을 짧게 설정하는 것을 목표로 합니다.

> **참고:** [CPU Scheduling Algorithms in Operating Systems - javatpoint](https://www.javatpoint.com/cpu-scheduling-algorithms-in-operating-systems)

---

## 비선점형 스케줄링 (Non-Preemptive Scheduling)

한 번 CPU를 할당받은 프로세스가 자발적으로 종료하거나, 입출력(I/O) 요청 등의 이유로 CPU를 반환할 때까지 다른 프로세스가 CPU를 차지할 수 없는 방식입니다. 현재 실행 중인 프로세스가 CPU 사용을 끝내기 전까지는 다른 프로세스가 그 자원을 사용할 수 없습니다.

### 비선점형의 특징
- **문맥 전환 최소화**: 실행 중인 프로세스를 강제로 중단하지 않으므로 문맥 전환이 적게 발생합니다. 이로 인해 오버헤드를 최소화할 수 있습니다.
    - **문맥 전환**: 다른 프로세스를 실행하기 위해 상태 정보를 저장하고 복구하는 과정.
    - **오버헤드**: 프로세스 실행 외에 발생하는 시스템의 추가적인 작업이나 자원 소모.
- **단점**: 긴 실행 시간을 가진 프로세스가 있을 경우, 다른 프로세스가 오랫동안 기다려야 할 수 있습니다.

---

## 주요 알고리즘

### 1. FCFS (First-Come, First-Served)
가장 단순한 CPU 스케줄링 알고리즘 중 하나로, "선착순" 방식으로 프로세스를 처리합니다. 먼저 도착한 프로세스가 먼저 CPU를 할당받고, 그 프로세스가 끝날 때까지 다른 프로세스는 기다려야 합니다.

#### 동작 방식
- **대기 큐**: 프로세스는 도착 순서대로 대기 큐에 들어갑니다.
- **실행 순서**: 첫 번째 도착한 프로세스가 먼저 실행됩니다.
- **처리 완료**: 첫 번째 프로세스가 끝나면 다음 프로세스가 실행됩니다.

#### 작동 예시
- **프로세스 도착 시나리오**:
    - P1: 도착 시간 0, 실행 시간 5
    - P2: 도착 시간 2, 실행 시간 2
    - P3: 도착 시간 4, 실행 시간 1
    - 처리 순서: P1 → P2 → P3
![CPU 스케줄링 알고리즘-FCFS.drawio.png](..%2F..%2F..%2FDownloads%2FCPU%20%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-FCFS.drawio.png)

#### FCFS의 주요 특징
- **비선점형**: 프로세스가 한 번 CPU를 할당받으면 작업을 마칠 때까지 CPU를 양보하지 않습니다.
- **간단한 구현**: FIFO(First-In, First-Out) 방식의 큐 자료구조를 이용하여 구현이 간단합니다.
- **공평성**: 도착 순서대로 CPU를 할당받습니다.

#### FCFS의 장점
- 구현이 쉬움.
- 공정성 보장.
- 처리 오버헤드가 적음.

#### FCFS의 단점
- **Convoy Effect**: 긴 프로세스가 먼저 도착하면 뒤에 도착한 짧은 프로세스들이 기다려야 할 수 있습니다.
- **평균 대기 시간이 길어짐**: 실행 시간이 긴 프로세스가 먼저 도착하면 전체 대기 시간이 길어집니다.

---

### 2. SJF (Shortest Job First)
각 프로세스의 실행 시간을 기준으로 가장 짧은 작업부터 먼저 처리하는 방식입니다. 평균 대기 시간을 최소화하는 것을 목표로 합니다.

#### SJF의 주요 개념
- **실행 시간(서비스 시간)**: 각 프로세스가 CPU에서 실행되는 데 필요한 시간입니다.
- **대기 시간**: 프로세스가 CPU를 할당받기 전까지 대기하는 시간입니다.


#### 비선점형 SJF (Non-Preemptive SJF)
- 한 번 CPU를 할당받은 프로세스는 끝날 때까지 CPU를 독점적으로 사용합니다.

#### 비선점형 SJF의 장점
- 단순한 구현.
- 문맥 전환 비용 감소.

#### 비선점형 SJF의 단점
- 긴 대기 시간 발생 가능.
- **Starvation(기아 현상)**: 짧은 작업이 오랫동안 대기할 수 있습니다.

---

### 3. Priority Scheduling (우선순위 스케줄링)
각 프로세스에 우선순위를 부여하고, 우선순위가 높은 프로세스에 CPU를 먼저 할당하는 스케줄링 방식입니다. 우선순위는 내부 또는 외부 요인에 따라 정해집니다.

#### 우선순위의 정의
- **내부 우선순위**: 시간 제한, 메모리 요구 사항 등.
- **외부 우선순위**: 작업의 중요성, 할당된 자금 등.

#### 비선점형 우선순위 스케줄링
- 현재 CPU를 사용 중인 프로세스가 완료될 때까지 CPU를 계속 사용합니다.
- 우선순위가 더 높은 프로세스가 도착해도 기다려야 합니다.

#### Priority Scheduling의 장점
- 중요한 작업 우선 처리.
- 우선순위를 동적으로 설정할 수 있어 유연함.

#### Priority Scheduling의 단점
- **Starvation(기아 현상)**: 낮은 우선순위의 프로세스가 CPU를 오랫동안 할당받지 못할 수 있습니다.
- **해결 방법**: **Aging** 기법으로 오래 대기한 프로세스의 우선순위를 점진적으로 높일 수 있습니다.

---

## 우선순위 스케줄링의 응용
- **실시간 시스템**: 중요한 작업을 우선적으로 처리할 때 유용합니다.
- **긴급한 작업이 많은 환경**: 우선순위가 높은 작업을 빨리 처리해야 하는 경우 적합합니다.
