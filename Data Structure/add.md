### 공간 복잡도(Space Complexity)
공간 복잡도는 알고리즘이 실행될 때 사용하는 메모리 양을 입력 크기와 관련하여 측정합니다. 공간 복잡도는 알고리즘이 사용하는 고정된 메모리 양(상수 공간)과 입력 크기에 따라 추가로 필요한 메모리 양(가변 공간)이 포함됩니다.

---

#### 상수 공간 O(1)
상수 공간을 사용하는 알고리즘은 입력 크기와 무관하게 일정한 양의 메모리를 사용합니다.

**예시:**
```java
int a = 5;
int b = 10;
int sum = a + b;
```

다음은 요청하신 내용을 마크다운 언어로 변환한 것입니다:

```markdown
### 공간 복잡도(Space Complexity)
공간 복잡도는 알고리즘이 실행될 때 사용하는 메모리 양을 입력 크기와 관련하여 측정합니다. 공간 복잡도는 알고리즘이 사용하는 고정된 메모리 양(상수 공간)과 입력 크기에 따라 추가로 필요한 메모리 양(가변 공간)이 포함됩니다.

---

#### 상수 공간 O(1)
상수 공간을 사용하는 알고리즘은 입력 크기와 무관하게 일정한 양의 메모리를 사용합니다.

**예시:**
```java
int a = 5;
int b = 10;
int sum = a + b;
```

---

### 재귀 함수와 공간 복잡도
재귀 함수는 호출될 때마다 스택에 저장되므로, 재귀 호출 깊이에 따라 공간 복잡도가 결정됩니다. 예를 들어, 피보나치 수열을 재귀적으로 구현하면, 재귀 호출 스택에 저장되는 함수의 수에 비례하여 메모리가 필요합니다.

**예시: 피보나치 수열을 재귀적으로 계산하는 함수의 공간 복잡도는 O(n)**
```java
int fibonacci(int n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}
```

---

### 시간 복잡도와 공간 복잡도의 균형
알고리즘을 최적화할 때는 시간 복잡도와 공간 복잡도 사이의 균형을 고려해야 합니다. 예를 들어, 더 빠른 알고리즘을 구현하기 위해 메모리를 더 많이 사용하는 방법(메모리-시간 트레이드 오프)을 선택할 수도 있습니다.

- **메모리-시간 트레이드 오프(Memory-Time Tradeoff):** 알고리즘의 성능을 최적화할 때 사용하는 중요한 개념으로, 메모리 사용량과 실행 시간 사이의 균형을 맞추는 방법을 의미합니다. 일반적으로 알고리즘에서 더 많은 메모리를 사용하면 실행 시간을 줄일 수 있고, 반대로 메모리를 덜 사용하면 실행 시간이 늘어날 수 있습니다.

---

### 요약
1. **시간 복잡도(Time Complexity)**: 입력 크기 \(n\)에 따라 알고리즘이 얼마나 빨리 동작하는지를 분석합니다. 일반적으로 빅오 표기법(Big-O Notation)을 통해 나타내며, 알고리즘이 처리해야 할 작업의 양을 예측합니다.
2. **공간 복잡도(Space Complexity)**: 입력 크기 \(n\)에 따라 알고리즘이 얼마나 많은 메모리를 사용하는지를 분석합니다. 이를 통해 메모리 사용량을 최적화할 수 있습니다.

## 자료 구조에서ㅓ의 시간 복잡도

### 자료 구조의 평균 시간 복잡도

| 자료 구조               | 접근 (Access) | 탐색 (Search) | 삽입 (Insert) | 삭제 (Delete) |
|-------------------------|----------------|---------------|---------------|---------------|
| 배열 (Array)            | O(1)           | O(n)          | O(n)          | O(n)          |
| 스택 (Stack)            | O(n)           | O(n)          | O(1)          | O(1)          |
| 큐 (Queue)              | O(n)           | O(n)          | O(1)          | O(1)          |
| 이중 연결 리스트 (Doubly Linked List) | O(n) | O(n)   | O(1)          | O(1)          |
| 해시 테이블 (Hash Table) | O(1)           | O(1)          | O(1)          | O(1)          |
| 이진 탐색 트리 (BST)    | O(log n)       | O(log n)      | O(log n)      | O(log n)      |
| AVL 트리 (AVL Tree)     | O(log n)       | O(log n)      | O(log n)      | O(log n)      |
| 레드 블랙 트리 (Red-Black Tree) | O(log n)  | O(log n)      | O(log n)      | O(log n)      |

---

### 자료 구조의 최악 시간 복잡도

| 자료 구조               | 접근 (Access) | 탐색 (Search) | 삽입 (Insert) | 삭제 (Delete) |
|-------------------------|----------------|---------------|---------------|---------------|
| 배열 (Array)            | O(1)           | O(n)          | O(n)          | O(n)          |
| 스택 (Stack)            | O(n)           | O(n)          | O(1)          | O(1)          |
| 큐 (Queue)              | O(n)           | O(n)          | O(1)          | O(1)          |
| 이중 연결 리스트 (Doubly Linked List) | O(n) | O(n)   | O(1)          | O(1)          |
| 해시 테이블 (Hash Table) | O(1)           | O(1)          | O(1)          | O(1)          |
| 이진 탐색 트리 (BST)    | O(log n)       | O(log n)      | O(log n)      | O(log n)      |
| AVL 트리 (AVL Tree)     | O(log n)       | O(log n)      | O(log n)      | O(log n)      |
| 레드 블랙 트리 (Red-Black Tree) | O(log n)  | O(log n)      | O(log n)      | O(log n)      |